{
  "question": {
    "title": "Check if the Sentence Is Pangram",
    "problemStatement": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "sentence = \"thequickbrownfoxjumpsoverthelazydog\"",
        "output": "true",
        "explanation": "sentence contains at least one of every letter of the English alphabet."
      },
      {
        "id": 2,
        "input": "sentence = \"leetcode\"",
        "output": "false",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= sentence.length <= 1000",
      "sentence consists of lowercase English letters."
    ]
  },
  "solution": {
    "language": "C++",
    "code": "class Solution {\npublic:\n    bool checkIfPangram(string str) {\n        int n = str.size();\n        vector<int> v(26,0);\n        \n        for(int i = 0; i < n; i++)\n        {\n            v[str[i]-'a']++;\n        }\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            if(v[i] == 0)\n                return false;\n        }\n    return true;\n    }\n};"
  },
  "analysis": {
    "time_complexity": "$O(n)$",
    "space_complexity": "$O(1)$",
    "explanation": "The time complexity is $O(n)$ where 'n' is the length of the input string, because we iterate through the string once to count the characters. The space complexity is $O(1)$ because the vector used for counting has a fixed size of 26, which is constant and does not depend on the input string size."
  },
  "metadata": {
    "topic": ["Array", "Hash Table", "String"],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Check if the Sentence Is Pangram",
    "problemStatement": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "sentence = \"thequickbrownfoxjumpsoverthelazydog\"",
        "output": "true",
        "explanation": "sentence contains at least one of every letter of the English alphabet."
      },
      {
        "id": 2,
        "input": "sentence = \"leetcode\"",
        "output": "false",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= sentence.length <= 1000",
      "sentence consists of lowercase English letters."
    ]
  },
  "solution": {
    "language": "C++",
    "code": "class Solution {\npublic:\n    bool checkIfPangram(string str) {\n        int n = str.size();\n        vector<int> v(26,0);\n        \n        for(int i = 0; i < n; i++)\n        {\n            v[str[i]-'a']++;\n        }\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            if(v[i] == 0)\n                return false;\n        }\n    return true;\n    }\n};"
  },
  "analysis": {
    "time_complexity": "$O(n)$",
    "space_complexity": "$O(1)$",
    "explanation": "The time complexity is $O(n)$, where 'n' is the length of the sentence, because we must iterate through the entire string once. The space complexity is $O(1)$ because the vector used to store the frequency of letters has a constant size of 26, regardless of the input string's length."
  },
  "metadata": {
    "topic": [
      "Array",
      "Hash Table",
      "String"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Check if the Sentence Is Pangram",
    "problemStatement": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "sentence = \"thequickbrownfoxjumpsoverthelazydog\"",
        "output": "true",
        "explanation": "sentence contains at least one of every letter of the English alphabet."
      },
      {
        "id": 2,
        "input": "sentence = \"leetcode\"",
        "output": "false",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= sentence.length <= 1000",
      "sentence consists of lowercase English letters."
    ]
  },
  "solution": {
    "language": "C++",
    "code": "class Solution {\npublic:\n    bool checkIfPangram(string str) {\n        int n = str.size();\n        vector<int> v(26,0);\n        \n        for(int i = 0; i < n; i++)\n        {\n            v[str[i]-'a']++;\n        }\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            if(v[i] == 0)\n                return false;\n        }\n    return true;\n    }\n};"
  },
  "analysis": {
    "time_complexity": "$O(n)$",
    "space_complexity": "$O(1)$",
    "explanation": "The time complexity is $O(n)$, where 'n' is the length of the sentence, because we iterate through the string once to populate the frequency array. The space complexity is $O(1)$ because the vector used for counting has a fixed size of 26, which is a constant and does not depend on the input string's size."
  },
  "metadata": {
    "topic": [
      "Array",
      "Hash Table",
      "String"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Count Items Matching a Rule",
    "problemStatement": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\n\nThe ith item is said to match the rule if one of the following is true:\n- ruleKey == \"type\" and ruleValue == typei.\n- ruleKey == \"color\" and ruleValue == colori.\n- ruleKey == \"name\" and ruleValue == namei.\n\nReturn the number of items that match the given rule.",
    "examples": [
      {
        "id": 1,
        "input": "items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"",
        "output": "1",
        "explanation": "There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"]."
      },
      {
        "id": 2,
        "input": "items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"",
        "output": "2",
        "explanation": "There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match."
      }
    ],
    "constraints": [
      "1 <= items.length <= 10^4",
      "1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10",
      "ruleKey is equal to either \"type\", \"color\", or \"name\".",
      "All strings consist only of lowercase letters."
    ]
  },
  "solution": {
    "language": "C++",
    "code": "class Solution {\npublic:\n    int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {\n        int n = items.size();\n        int x, c = 0;\n        \n        if(ruleKey == \"type\") x = 0;\n        if(ruleKey == \"color\") x = 1;\n        if(ruleKey == \"name\") x = 2;\n        \n        for(int i = 0; i < n; i++)\n        {\n            if(items[i][x] == ruleValue)\n                c++;\n        }\n        \n        return c;\n    }\n};"
  },
  "analysis": {
    "time_complexity": "$O(n)$",
    "space_complexity": "$O(1)$",
    "explanation": "The time complexity is $O(n)$, where 'n' is the total number of items in the list. This is because we need to iterate through each item once to check if it matches the rule. The space complexity is $O(1)$ as we only use a few variables to store the count and index, which does not scale with the size of the input."
  },
  "metadata": {
    "topic": [
      "Array",
      "String"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Create Target Array in the Given Order",
    "problemStatement": "Given two arrays of integers nums and index. Your task is to create target array under the following rules:\n- Initially target array is empty.\n- From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.\n- Repeat the previous step until there are no elements to read in nums and index.\nReturn the target array.\nIt is guaranteed that the insertion operations will be valid.",
    "examples": [
      {
        "id": 1,
        "input": "nums = [0,1,2,3,4], index = [0,1,2,2,1]",
        "output": "[0,4,1,3,2]",
        "explanation": "nums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]"
      },
      {
        "id": 2,
        "input": "nums = [1,2,3,4,0], index = [0,1,2,3,0]",
        "output": "[0,1,2,3,4]",
        "explanation": "nums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]"
      },
      {
        "id": 3,
        "input": "nums = [1], index = [0]",
        "output": "[1]",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= nums.length, index.length <= 100",
      "nums.length == index.length",
      "0 <= nums[i] <= 100",
      "0 <= index[i] <= i"
    ]
  },
  "solution": {
    "language": "C++",
    "code": "class Solution {\npublic:\n    vector<int> createTargetArray(vector<int>& v1, vector<int>& v2) {\n        int n = v2.size();\n        vector<int> r;\n        for(int i = 0; i < n; i++)\n        {\n            r.insert(r.begin() + v2[i], v1[i]);\n        }\n        return r;\n    }\n};"
  },
  "analysis": {
    "time_complexity": "$O(n^2)$",
    "space_complexity": "$O(n)$",
    "explanation": "The time complexity is $O(n^2)$ because the `insert` operation on a vector can take linear time. In the worst case, inserting an element at the beginning of the vector requires shifting all existing elements, which takes $O(k)$ time for a vector of size $k$. Since this is done inside a loop that runs $n$ times, the total time complexity is the sum of $1 + 2 + ... + n$, which is $O(n^2)$. The space complexity is $O(n)$ to store the target array which will have $n$ elements."
  },
  "metadata": {
    "topic": [
      "Array",
      "Simulation"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "XOR Operation in an Array",
    "problemStatement": "You are given an integer n and an integer start.\n\nDefine an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.\n\nReturn the bitwise XOR of all elements of nums.",
    "examples": [
      {
        "id": 1,
        "input": "n = 5, start = 0",
        "output": "8",
        "explanation": "Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere \"^\" corresponds to bitwise XOR operator."
      },
      {
        "id": 2,
        "input": "n = 4, start = 3",
        "output": "8",
        "explanation": "Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "0 <= start <= 1000",
      "n == nums.length"
    ]
  },
  "solutions": [
    {
      "language": "C++",
      "code": "class Solution {\npublic:\n    int xorOperation(int n, int start) {\n        int x = start;\n        for(int i = 1; i < n; i++)\n        {\n            x = x ^ (start + 2*i);\n        }\n        return x;\n    }\n};"
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        x = start\n        for i in range(1, n):\n            x = x ^ (start + 2*i)\n        return x"
    }
  ],
  "analysis": {
    "time_complexity": "$O(n)$",
    "space_complexity": "$O(1)$",
    "explanation": "The time complexity is $O(n)$ because the solution involves a single loop that iterates from 1 to n-1. The operations inside the loop are constant time. The space complexity is $O(1)$ because the algorithm only uses a few variables to store the result and the loop counter, without creating the full array in memory. The space used is constant regardless of the input size 'n'."
  },
  "metadata": {
    "topic": [
      "Bit Manipulation",
      "Array",
      "Math"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Climbing Stairs",
    "problemStatement": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "id": 1,
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
      },
      {
        "id": 2,
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ]
  },
  "solutions": [
    {
      "approach_name": "Dynamic Programming (Tabulation)",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This approach builds a DP array (or table) from the bottom up. The array `a` stores the number of ways to reach each step, where `a[i] = a[i-1] + a[i-2]`. We iterate once from 2 to n, resulting in linear time complexity. An array of size n+1 is used to store the intermediate results, leading to linear space complexity."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n <= 1) return 1;\n        int a[n+1];\n        a[0] = 1, a[1] = 1;\n        for(int i = 2; i <= n; i++){\n            a[i] = a[i-2] + a[i-1];\n        }\n        return a[n];\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1: return 1\n        arr = [1, 1]\n        for i in range(2, n+1):\n            arr.append(arr[i-2] + arr[i-1])\n        return arr[n]"
        }
      ]
    },
    {
      "approach_name": "Dynamic Programming (Space Optimized)",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This is an optimization of the tabulation method. Since calculating the number of ways for the current step only requires the results from the previous two steps, we don't need to store the entire DP array. We can use two variables to keep track of the last two results and a third to calculate the current one. This maintains the $O(n)$ time complexity but reduces the space complexity to constant."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if(n <= 2) return n;\n        int a = 1, b = 2, ans;\n        for(int i = 3; i <= n; i++){\n            ans = a + b;\n            a = b;\n            b = ans;\n        }\n        return ans;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if(n <= 2): return n\n        a, b, ans = 1, 2, 0\n        for i in range(3, n+1):\n            ans = a + b\n            a = b\n            b = ans\n        return ans"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Dynamic Programming",
      "Math",
      "Memoization"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Counting Bits",
    "problemStatement": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "examples": [
      {
        "id": 1,
        "input": "n = 2",
        "output": "[0,1,1]",
        "explanation": "0 --> 0\n1 --> 1\n2 --> 10"
      },
      {
        "id": 2,
        "input": "n = 5",
        "output": "[0,1,1,2,1,2]",
        "explanation": "0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
      }
    ],
    "constraints": [
      "0 <= n <= 10^5"
    ]
  },
  "solutions": [
    {
      "approach_name": "Dynamic Programming with Bit Manipulation",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This approach uses dynamic programming to efficiently calculate the number of set bits. We build an array `dp` where `dp[i]` stores the bit count for integer `i`. The key insight is that the bit count of `i` can be derived from a smaller number. For instance, the number of 1s in `i` is the number of 1s in `i / 2` (or `i >> 1`) plus the last bit of `i` (`i % 2`). This allows us to fill the array in a single pass, achieving linear time complexity. The space complexity is also linear as we need to store the result for each number from 0 to n."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> dp(n+1);\n        dp[0] = 0;\n        for(int i = 1; i < n+1; i++)\n        {\n            dp[i] = dp[i/2] + i%2;\n        }\n        return dp;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n+1):\n            # The Python solution provided can be simplified to the same logic as the C++ one\n            # dp[i] = dp[i >> 1] + (i & 1)\n            # Original provided logic:\n            if i%2 == 1:\n                dp[i] = dp[i-1] + 1\n            else:\n                dp[i] = dp[i//2]\n        return dp"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Dynamic Programming",
      "Bit Manipulation"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Min Cost Climbing Stairs",
    "problemStatement": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index 0, or the step with index 1.\n\nReturn the minimum cost to reach the top of the floor.",
    "examples": [
      {
        "id": 1,
        "input": "cost = [10,15,20]",
        "output": "15",
        "explanation": "You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15."
      },
      {
        "id": 2,
        "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
        "output": "6",
        "explanation": "You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
      }
    ],
    "constraints": [
      "2 <= cost.length <= 1000",
      "0 <= cost[i] <= 999"
    ]
  },
  "solutions": [
    {
      "approach_name": "Dynamic Programming (Space-Optimized)",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This approach uses dynamic programming with constant space. It iterates up to the 'top' of the staircase (one step beyond the end of the array), calculating the minimum cost to reach each step. Instead of using a full DP array, it only keeps track of the minimum costs to reach the previous two steps using variables, which reduces the space complexity to $O(1)$ while maintaining a single pass, resulting in $O(n)$ time."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int dp = 0, dp1 = 0, dp2 = 0;\n        for(int i = 2; i <= cost.size(); i++){\n            int one = dp1 + cost[i-1];\n            int two = dp2 + cost[i-2];\n            dp = min(one, two);\n            dp2 = dp1;\n            dp1 = dp;\n        }\n        return dp1;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp, dp1, dp2 = 0, 0, 0\n        for i in range(2, len(cost)+1):\n            one = dp1 + cost[i-1]\n            two = dp2 + cost[i-2]\n            dp = min(one, two)\n            dp2 = dp1\n            dp1 = dp\n        return dp1"
        }
      ]
    },
    {
      "approach_name": "Dynamic Programming (In-place)",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This approach also uses dynamic programming but cleverly modifies the input `cost` array to serve as the DP table, thus using no extra space. It iterates from the third step, updating `cost[i]` to be the minimum cost to reach that step (`cost[i] + min(cost[i-1], cost[i-2])`). The final result is the minimum cost to reach either of the last two steps, from which you can reach the top. This method is space-efficient but has the side effect of modifying the input array."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        for(int i = 2; i < n; i++){\n            cost[i] += min(cost[i-1], cost[i-2]);\n        }\n        return min(cost[n-1], cost[n-2]);\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(2, len(cost)):\n            cost[i] += min(cost[i-1], cost[i-2])\n        return min(cost[-1], cost[-2])"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Dynamic Programming",
      "Array"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Pascal's Triangle II",
    "problemStatement": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.",
    "examples": [
      {
        "id": 1,
        "input": "rowIndex = 3",
        "output": "[1,3,3,1]"
      },
      {
        "id": 2,
        "input": "rowIndex = 0",
        "output": "[1]"
      },
      {
        "id": 3,
        "input": "rowIndex = 1",
        "output": "[1,1]"
      }
    ],
    "constraints": [
      "0 <= rowIndex <= 33"
    ]
  },
  "solutions": [
    {
      "approach_name": "Dynamic Programming (In-place Row Calculation)",
      "analysis": {
        "time_complexity": "$O(k^2)$",
        "space_complexity": "$O(k)$",
        "explanation": "This approach builds the target row (let's say row `k`) iteratively using a single array of size `k+1`. The outer loop simulates moving from one row to the next, while the inner loop calculates the new values for the current row. The inner loop must run backwards to ensure that when calculating `ans[j] = ans[j] + ans[j-1]`, the `ans[j-1]` value is from the previous row's state, not the newly updated current row. The time complexity is quadratic in the row index `k` due to the nested loops. The space complexity is $O(k)$ as it only stores the single row being computed."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> ans(rowIndex+1, 0);\n        ans[0] = 1;\n        for(int i = 1; i < rowIndex+1; i++)\n            for(int j = i; j >= 1; j--)\n                ans[j] += ans[j-1];\n        return ans;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        ans = [1]*(rowIndex + 1)\n        for i in range(2, rowIndex+1):\n            for j in range(i-1, 0, -1):\n                ans[j] += ans[j-1]\n        return ans"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Array",
      "Dynamic Programming"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Find if Path Exists in Graph",
    "problemStatement": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\n\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2",
        "output": "true",
        "explanation": "There are two paths from vertex 0 to vertex 2:\n- 0 → 1 → 2\n- 0 → 2"
      },
      {
        "id": 2,
        "input": "n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5",
        "output": "false",
        "explanation": "There is no path from vertex 0 to vertex 5."
      }
    ],
    "constraints": [
      "1 <= n <= 2 * 10^5",
      "0 <= edges.length <= 2 * 10^5",
      "edges[i].length == 2",
      "0 <= ui, vi <= n - 1",
      "ui != vi",
      "0 <= source, destination <= n - 1",
      "There are no duplicate edges.",
      "There are no self edges."
    ]
  },
  "solutions": [
    {
      "approach_name": "Breadth-First Search (BFS)",
      "analysis": {
        "time_complexity": "$O(V + E)$",
        "space_complexity": "$O(V + E)$",
        "explanation": "This solution uses Breadth-First Search (BFS) to determine connectivity. First, it constructs an adjacency list representation of the graph from the edges, which takes $O(E)$ time and space, where E is the number of edges. Then, it performs a BFS starting from the `source` node. A queue is used to explore nodes level by level, and a `visited` array tracks visited nodes to prevent cycles. The traversal visits each vertex and edge in the connected component at most once. The overall time and space complexity is $O(V + E)$, where V is the number of vertices and E is the number of edges, as this accounts for building the graph and the traversal itself."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination){\n        vector<vector<int>> graph(n);\n        for(int i = 0; i < edges.size(); i++){\n            graph[edges[i][0]].push_back(edges[i][1]);\n            graph[edges[i][1]].push_back(edges[i][0]);\n        }\n        queue<int> q;\n        vector<int> visited(n, 0);\n        q.push(source);\n        visited[source] = 1;\n        while(!q.empty()){\n            int top = q.front();\n            q.pop();\n            if(top == destination)\n                return true;\n            for(int i=0; i<graph[top].size(); i++){\n                if(visited[graph[top][i]] == 0){\n                    q.push(graph[top][i]);\n                    visited[graph[top][i]] = 1;\n                }\n            }\n        }\n        return false;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Graph",
      "Breadth-First Search",
      "Depth-First Search",
      "Union-Find"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Convert Binary Number in a Linked List to Integer",
    "problemStatement": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\n\nReturn the decimal value of the number in the linked list.\n\nThe most significant bit is at the head of the linked list.",
    "examples": [
      {
        "id": 1,
        "input": "head = [1,0,1]",
        "output": "5",
        "explanation": "(101) in base 2 = (5) in base 10"
      },
      {
        "id": 2,
        "input": "head = [0]",
        "output": "0",
        "explanation": null
      }
    ],
    "constraints": [
      "The Linked List is not empty.",
      "Number of nodes will not exceed 30.",
      "Each node's value is either 0 or 1."
    ]
  },
  "solutions": [
    {
      "approach_name": "Iterative Bitwise Left Shift",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This approach iterates through the linked list from head to tail in a single pass. It uses a variable, `ans`, initialized to zero, to build the decimal number. For each node, it updates `ans` by shifting its bits to the left by one (which is equivalent to multiplying by 2) and then adding the current node's value. This correctly processes the binary number from most significant to least significant bit. The time complexity is $O(n)$ as we visit each node once, and the space complexity is $O(1)$ as we only use a single variable for the result."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int ans = 0;\n        while(head)\n        {\n            ans = (ans << 1) + head -> val;\n            head = head -> next;\n        }\n        return ans;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Linked List",
      "Bit Manipulation",
      "Math"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Delete Node in a Linked List",
    "problemStatement": "There is a singly-linked list head and we want to delete a node node in it.\n\nYou are given the node to be deleted node. You will not be given access to the first node of head.\n\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n- The value of the given node should not exist in the linked list.\n- The number of nodes in the linked list should decrease by one.\n- All the values before node should be in the same order.\n- All the values after node should be in the same order.",
    "examples": [
      {
        "id": 1,
        "input": "head = [4,5,1,9], node = 5",
        "output": "[4,1,9]",
        "explanation": "You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function."
      },
      {
        "id": 2,
        "input": "head = [4,5,1,9], node = 1",
        "output": "[4,5,9]",
        "explanation": "You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function."
      }
    ],
    "constraints": [
      "The number of the nodes in the given list is in the range [2, 1000].",
      "-1000 <= Node.val <= 1000",
      "The value of each node in the list is unique.",
      "The node to be deleted is in the list and is not a tail node."
    ]
  },
  "solutions": [
    {
      "approach_name": "Copy Next Node's Value",
      "analysis": {
        "time_complexity": "$O(1)$",
        "space_complexity": "$O(1)$",
        "explanation": "Since we do not have access to the node before the one to be deleted, we cannot perform a standard deletion. The solution is to effectively replace the node to be deleted with its subsequent node. This is done by copying the value of the next node into the current node, and then updating the current node's `next` pointer to skip the next node and point to the one after it. This achieves the desired outcome in constant time and space, as it only requires a few value and pointer reassignments."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        ListNode* temp = node -> next;\n        node -> val = temp -> val;\n        node -> next = temp -> next;\n        delete temp;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Linked List"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Linked List Cycle",
    "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "examples": [
      {
        "id": 1,
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "id": 2,
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "id": 3,
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "constraints": [
      "The number of the nodes in the list is in the range [0, 10^4].",
      "-10^5 <= Node.val <= 10^5",
      "pos is -1 or a valid index in the linked-list."
    ]
  },
  "solutions": [
    {
      "approach_name": "Floyd's Tortoise and Hare Algorithm",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This solution uses the two-pointer technique known as Floyd's Tortoise and Hare algorithm. A 'slow' pointer moves one step at a time, while a 'fast' pointer moves two steps. If there is a cycle, the fast pointer will eventually enter the cycle and lap the slow pointer, causing them to meet at the same node. If there is no cycle, the fast pointer (or its next) will reach the end of the list (`NULL`). This approach cleverly detects a cycle in linear time, as it processes each node a constant number of times, and uses constant extra space for the two pointers."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode *fast = head;\n        ListNode *slow = head;\n        \n        while(fast != NULL && fast -> next != NULL)\n        {\n            fast = fast -> next -> next;\n            slow = slow -> next;\n            \n            if(fast == slow)\n                return true;\n        }\n        \n        return false;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Linked List",
      "Two Pointers",
      "Hash Table"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Add Digits",
    "problemStatement": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.",
    "examples": [
      {
        "id": 1,
        "input": "num = 38",
        "output": "2",
        "explanation": "The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it."
      },
      {
        "id": 2,
        "input": "num = 0",
        "output": "0",
        "explanation": null
      }
    ],
    "constraints": [
      "0 <= num <= 2^31 - 1"
    ]
  },
  "solutions": [
    {
      "approach_name": "Digital Root (Mathematical Property)",
      "analysis": {
        "time_complexity": "$O(1)$",
        "space_complexity": "$O(1)$",
        "explanation": "This solution leverages a mathematical property related to digital roots. The result of repeatedly summing digits is the number itself modulo 9, with the special case that if the number is a multiple of 9 (and not 0), the result is 9. This allows the problem to be solved without any loops or recursion, by directly applying this formula. The approach is highly efficient, with constant time and space complexity."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int addDigits(int num) {\n        if(num == 0)\n            return 0;\n        else if(num % 9 == 0)\n            return 9;\n        else \n            return num % 9;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Math"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Happy Number",
    "problemStatement": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process:\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy.\n\nReturn true if n is a happy number, and false if not.",
    "examples": [
      {
        "id": 1,
        "input": "n = 19",
        "output": "true",
        "explanation": "1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1"
      },
      {
        "id": 2,
        "input": "n = 2",
        "output": "false",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ]
  },
  "solutions": [
    {
      "approach_name": "Hash Set Cycle Detection",
      "analysis": {
        "time_complexity": "$O(\\log n)$",
        "space_complexity": "$O(\\log n)$",
        "explanation": "This approach detects if a number is happy by simulating the process and checking for cycles using a hash set (or map). It stores each newly calculated number in the set. If a number is generated that is already in the set, a cycle has been found, and the number is not happy. If the number becomes 1, it's happy. The time and space complexity are related to $O(\\log n)$ because the value of the numbers in the sequence drops very quickly to a small, constant-bounded range."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_map<int, int> mp;\n        while(n != 1)\n        {\n            if(mp[n] == 0)\n                mp[n]++;\n            else\n                return false;\n            \n            int sum = 0;\n            while(n != 0)\n            {\n                sum += pow(n%10, 2);\n                n /= 10;\n            }\n            n = sum;\n        }\n        return true;\n    }\n};"
        }
      ]
    },
    {
      "approach_name": "Hardcoded Cycle Detection",
      "analysis": {
        "time_complexity": "$O(\\log n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This approach uses the mathematical property that all unhappy numbers eventually fall into the cycle containing 4 (4 → 16 → 37 → ... → 4). By repeatedly calculating the sum of squares, we can stop once the number is very small (e.g., less than 5). At that point, if the number is 1, it's a happy number; otherwise, it must be on a path to the '4' cycle. This method avoids the need for extra space to store visited numbers."
      },
      "implementations": [
        {
          "language": "Python",
          "code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        while n > 4:\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Math"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Fibonacci Number",
    "problemStatement": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).",
    "examples": [
      {
        "id": 1,
        "input": "n = 2",
        "output": "1",
        "explanation": "F(2) = F(1) + F(0) = 1 + 0 = 1."
      },
      {
        "id": 2,
        "input": "n = 3",
        "output": "2",
        "explanation": "F(3) = F(2) + F(1) = 1 + 1 = 2."
      },
      {
        "id": 3,
        "input": "n = 4",
        "output": "3",
        "explanation": "F(4) = F(3) + F(2) = 2 + 1 = 3."
      }
    ],
    "constraints": [
      "0 <= n <= 30"
    ]
  },
  "solutions": [
    {
      "approach_name": "Simple Recursion",
      "analysis": {
        "time_complexity": "$O(2^n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This solution directly implements the mathematical definition of the Fibonacci sequence using recursion. It establishes base cases for n=0 and n=1 and makes two recursive calls for larger n. While conceptually simple, this approach is highly inefficient due to redundant calculations of the same Fibonacci numbers, resulting in an exponential time complexity. The space complexity is determined by the maximum depth of the recursion stack, which is proportional to n."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int fib(int n) {\n        if(n == 0)\n        {\n            return 0;    \n        }\n        \n        else if(n == 1)\n        {\n            return 1;\n        }\n        \n        int sum = fib(n-1) + fib(n-2);\n        return sum;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Recursion"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Number of Steps to Reduce a Number to Zero",
    "problemStatement": "Given an integer num, return the number of steps to reduce it to zero.\n\nIn one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.",
    "examples": [
      {
        "id": 1,
        "input": "num = 14",
        "output": "6",
        "explanation": "Step 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0."
      },
      {
        "id": 2,
        "input": "num = 8",
        "output": "4",
        "explanation": "Step 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0."
      },
      {
        "id": 3,
        "input": "num = 123",
        "output": "12",
        "explanation": null
      }
    ],
    "constraints": [
      "0 <= num <= 10^6"
    ]
  },
  "solutions": [
    {
      "approach_name": "Iterative Simulation",
      "analysis": {
        "time_complexity": "$O(\\log n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This solution directly simulates the reduction process using a `while` loop. In each step, it checks if the number is even or odd and applies the corresponding rule, incrementing a counter until the number becomes zero. The time complexity is logarithmic with respect to the input number `n`. This is because each division by 2 is equivalent to a bit shift, effectively reducing the number of bits, and each subtraction from an odd number makes it even, guaranteeing a division in the next step. The space complexity is constant as only a few variables are used."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int numberOfSteps(int num) {\n        int c = 0;\n        while(num > 0)\n        {\n            if(num % 2 == 0)\n            {\n                num /= 2;\n            }\n            else\n            {\n                num -= 1;\n            }\n            c++;\n        }\n        return c;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Recursion"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Reverse String",
    "problemStatement": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.",
    "examples": [
      {
        "id": 1,
        "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
        "explanation": null
      },
      {
        "id": 2,
        "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
        "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
        "explanation": null
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ascii character."
    ]
  },
  "solutions": [
    {
      "approach_name": "Two-Pointer Swap (In-place)",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This solution uses a classic two-pointer approach to reverse the array in-place. A 'start' pointer is initialized at the beginning of the array and an 'end' pointer at the end. The characters at these pointers are swapped, and then the start pointer is moved forward and the end pointer is moved backward. This process continues until the pointers meet or cross, effectively reversing the array. The time complexity is linear, as it iterates through half of the array. The space complexity is constant, satisfying the in-place requirement."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int start = 0, end = s.size() - 1;\n        while(start < end)\n        {\n            swap(s[start], s[end]);\n            start++;\n            end--;\n        }\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Recursion"
    ],
    "difficulty": "Easy"
  }
}

{
  "question": {
    "title": "Split Array into Consecutive Subsequences",
    "problemStatement": "You are given an integer array nums that is sorted in non-decreasing order.\n\nDetermine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\n- Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\n- All subsequences have a length of 3 or more.\n\nReturn true if you can split nums according to the above conditions, or false otherwise.\n\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).",
    "examples": [
      {
        "id": 1,
        "input": "nums = [1,2,3,3,4,5]",
        "output": "true",
        "explanation": "nums can be split into the following subsequences:\n[1,2,3,3,4,5] --> 1, 2, 3\n[1,2,3,3,4,5] --> 3, 4, 5"
      },
      {
        "id": 2,
        "input": "nums = [1,2,3,3,4,4,5,5]",
        "output": "true",
        "explanation": "nums can be split into the following subsequences:\n[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5\n[1,2,3,3,4,4,5,5] --> 3, 4, 5"
      },
      {
        "id": 3,
        "input": "nums = [1,2,3,4,4,5]",
        "output": "false",
        "explanation": "It is impossible to split nums into consecutive increasing subsequences of length 3 or more."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-1000 <= nums[i] <= 1000",
      "nums is sorted in non-decreasing order."
    ]
  },
  "solutions": [
    {
      "approach_name": "Greedy with Hash Maps",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This solution employs a greedy strategy using two hash maps. The first map (`mp1`) tracks the frequency of available numbers, while the second map (`mp2`) tracks the number of subsequences ending at a specific number. We iterate through the input array. For each number `x`, we first try to append it to an existing subsequence ending at `x-1`. If this is not possible, we try to start a new subsequence of length 3 with `x`, `x+1`, and `x+2`. If neither option is feasible, the split is impossible. This single pass through the array with constant-time hash map operations leads to a linear time complexity. The space complexity is also linear due to the storage required for the maps."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool isPossible(vector<int>& v) {\n        unordered_map<int, int> mp1, mp2;\n        for(auto x: v)\n            mp1[x]++;\n        \n        for(auto x: v){\n            if(mp1[x] == 0)  continue;\n            mp1[x]--;\n            \n            if(mp2[x-1] > 0){\n                mp2[x-1]--;\n                mp2[x]++;\n            }\n            else if(mp1[x+1] > 0 and mp1[x+2] > 0){\n                mp1[x+1]--;\n                mp1[x+2]--;\n                mp2[x+2]++;\n            }\n            else\n                return false;\n        }\n        return true;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def isPossible(self, v: List[int]) -> bool:\n        mp1 = collections.Counter(v)\n        mp2 = collections.Counter()\n        \n        for x in v:\n            if not mp1[x]:  continue\n            mp1[x] -= 1\n            \n            if mp2[x-1] > 0:\n                mp2[x-1] -= 1\n                mp2[x] += 1\n            elif mp1[x+1] and mp1[x+2]:\n                mp1[x+1] -= 1\n                mp1[x+2] -= 1\n                mp2[x+2] += 1\n            else:\n                return False\n        return True"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Array"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Reduce Array Size to The Half",
    "problemStatement": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\n\nReturn the minimum size of the set so that at least half of the integers of the array are removed.",
    "examples": [
      {
        "id": 1,
        "input": "arr = [3,3,3,3,5,5,5,2,2,7]",
        "output": "2",
        "explanation": "Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array."
      },
      {
        "id": 2,
        "input": "arr = [7,7,7,7,7,7]",
        "output": "1",
        "explanation": "The only possible set you can choose is {7}. This will make the new array empty."
      }
    ],
    "constraints": [
      "2 <= arr.length <= 10^5",
      "arr.length is even.",
      "1 <= arr[i] <= 10^5"
    ]
  },
  "solutions": [
    {
      "approach_name": "Greedy with Frequency Counting",
      "analysis": {
        "time_complexity": "$O(n \\log n)$",
        "space_complexity": "$O(n)$",
        "explanation": "The core idea is a greedy one: to remove at least half the elements using the minimum number of unique integers, we should always remove the integers that appear most frequently. The algorithm first counts the frequency of each number using a hash map. Then, it sorts these frequencies in descending order and iteratively removes the counts (starting with the largest) until the total number of removed elements is at least half of the original array's size. The number of unique elements removed is the answer. This sorting step can be done using a standard sort on a vector or by using a max-heap (priority queue), both leading to a similar time complexity."
      },
      "implementations": [
        {
          "language": "C++ (Sort)",
          "code": "class Solution {\npublic:\n    int minSetSize(vector<int>& arr) {\n        int ans = 0, c = 0;\n        unordered_map<int, int> mp;\n        for(auto x: arr)\n            mp[x]++;\n\n        vector<int> v;\n        for(auto it: mp)\n            v.push_back(it.second);\n\n        sort(v.rbegin(), v.rend()); // Sort descending\n        for(int i = 0; i < v.size(); i++){\n            ans += v[i];\n            c++;\n            if(ans >= arr.size()/2)\n                return c;\n        }\n        return c;\n    }\n};"
        },
        {
          "language": "C++ (Priority Queue)",
          "code": "class Solution {\npublic:\n    int minSetSize(vector<int>& arr) {\n        int x = 0, ans = 0;\n        unordered_map<int, int> mp;\n        for(auto i: arr)\n            mp[i]++;\n\n        priority_queue<int> pq;\n        for(auto i: mp)\n            pq.push(i.second);\n\n        while(x < arr.size()/2){\n            x += pq.top();\n            pq.pop();\n            ans++;\n        }\n        return ans;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Array"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Numbers With Same Consecutive Differences",
    "problemStatement": "Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order.\n\nNote that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.",
    "examples": [
      {
        "id": 1,
        "input": "n = 3, k = 7",
        "output": "[181,292,707,818,929]",
        "explanation": "Note that 070 is not a valid number, because it has leading zeroes."
      },
      {
        "id": 2,
        "input": "n = 2, k = 1",
        "output": "[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]",
        "explanation": null
      }
    ],
    "constraints": [
      "2 <= n <= 9",
      "0 <= k <= 9"
    ]
  },
  "solutions": [
    {
      "approach_name": "Backtracking (DFS)",
      "analysis": {
        "time_complexity": "$O(n \\cdot 2^n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This solution uses a backtracking approach, specifically a Depth-First Search (DFS), to construct the valid numbers. A recursive function builds the numbers digit by digit. Starting with initial digits 1 through 9 (to avoid leading zeros), the function explores all valid next digits. For any current last digit `d`, the next digit can be `d+k` or `d-k` (if they are within the 0-9 range). The recursion continues until a number of length `n` is formed. The time complexity is roughly the number of solutions ($O(2^n)$) multiplied by the time to build each solution ($O(n)$). The auxiliary space complexity is $O(n)$ due to the recursion stack depth."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    vector<int> ans;\n    void solve(int len, int &k, int num, int digit){\n        if(len == 0){\n            ans.push_back(num);\n            return;\n        }\n        int next_digit_add = digit + k;\n        int next_digit_sub = digit - k;\n\n        if(next_digit_add >= 0 && next_digit_add < 10){\n            solve(len-1, k, num*10 + next_digit_add, next_digit_add);\n        }\n\n        // Avoid double counting if k is 0\n        if(k != 0 && next_digit_sub >= 0 && next_digit_sub < 10){\n            solve(len-1, k, num*10 + next_digit_sub, next_digit_sub);\n        }\n    }\n    \n    vector<int> numsSameConsecDiff(int n, int k) {\n        for(int i = 1; i <= 9; i++)      \n            solve(n-1, k, i, i);\n        return ans;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Backtracking"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Numbers With Same Consecutive Differences",
    "problemStatement": "Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order.\n\nNote that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.",
    "examples": [
      {
        "id": 1,
        "input": "n = 3, k = 7",
        "output": "[181,292,707,818,929]",
        "explanation": "Note that 070 is not a valid number, because it has leading zeroes."
      },
      {
        "id": 2,
        "input": "n = 2, k = 1",
        "output": "[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]",
        "explanation": null
      }
    ],
    "constraints": [
      "2 <= n <= 9",
      "0 <= k <= 9"
    ]
  },
  "solutions": [
    {
      "approach_name": "Backtracking (DFS)",
      "analysis": {
        "time_complexity": "$O(n \\cdot 2^n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This solution uses a backtracking approach, specifically a Depth-First Search (DFS), to construct the valid numbers. A recursive function builds the numbers digit by digit. Starting with initial digits 1 through 9 (to avoid leading zeros), the function explores all valid next digits. For any current last digit `d`, the next digit can be `d+k` or `d-k` (if they are within the 0-9 range). The recursion continues until a number of length `n` is formed. The time complexity is roughly the number of solutions ($O(2^n)$) multiplied by the time to build each solution ($O(n)$). The auxiliary space complexity is $O(n)$ due to the recursion stack depth."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    vector<int> ans;\n    void solve(int len, int &k, int num, int digit){\n        if(len == 0){\n            ans.push_back(num);\n            return;\n        }\n        int next_digit_add = digit + k;\n        int next_digit_sub = digit - k;\n\n        if(next_digit_add >= 0 && next_digit_add < 10){\n            solve(len-1, k, num*10 + next_digit_add, next_digit_add);\n        }\n\n        // Avoid double counting if k is 0\n        if(k != 0 && next_digit_sub >= 0 && next_digit_sub < 10){\n            solve(len-1, k, num*10 + next_digit_sub, next_digit_sub);\n        }\n    }\n    \n    vector<int> numsSameConsecDiff(int n, int k) {\n        for(int i = 1; i <= 9; i++)      \n            solve(n-1, k, i, i);\n        return ans;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Backtracking"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Keys and Rooms",
    "problemStatement": "There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "We visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true."
      },
      {
        "id": 2,
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "We can not enter room number 2 since the only key that unlocks it is in that room."
      }
    ],
    "constraints": [
      "n == rooms.length",
      "2 <= n <= 1000",
      "0 <= rooms[i].length <= 1000",
      "1 <= sum(rooms[i].length) <= 3000",
      "0 <= rooms[i][j] < n",
      "All the values of rooms[i] are unique."
    ]
  },
  "solutions": [
    {
      "approach_name": "Graph Traversal (BFS)",
      "analysis": {
        "time_complexity": "$O(V + E)$",
        "space_complexity": "$O(V)$",
        "explanation": "This problem can be modeled as finding if all nodes in a graph are reachable from a starting node (room 0). The rooms represent the vertices (V) and the keys represent the directed edges (E). This solution employs a Breadth-First Search (BFS) to traverse the graph. It uses a queue to manage the rooms to visit and a boolean array to track visited rooms. Starting from room 0, it explores all reachable rooms. Finally, it checks the visited array to see if all rooms were reached. The time complexity is $O(V + E)$ because every room and key is processed once. The space complexity is $O(V)$ to store the queue and the visited array."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        int n = rooms.size();\n        vector<bool> vis(n, false);\n        queue<int> q;\n        q.push(0);\n        vis[0] = true;\n        \n        while(!q.empty()){\n            int room = q.front();\n            q.pop();\n            for(auto it: rooms[room]){\n                if(!vis[it]){\n                    q.push(it);\n                    vis[it] = true;\n                }\n            }\n        }\n        for(auto it: vis)\n            if(!it)\n                return false;\n        return true;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Graph"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Keys and Rooms",
    "problemStatement": "There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "We visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true."
      },
      {
        "id": 2,
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "We can not enter room number 2 since the only key that unlocks it is in that room."
      }
    ],
    "constraints": [
      "n == rooms.length",
      "2 <= n <= 1000",
      "0 <= rooms[i].length <= 1000",
      "1 <= sum(rooms[i].length) <= 3000",
      "0 <= rooms[i][j] < n",
      "All the values of rooms[i] are unique."
    ]
  },
  "solutions": [
    {
      "approach_name": "Graph Traversal (BFS)",
      "analysis": {
        "time_complexity": "$O(V + E)$",
        "space_complexity": "$O(V)$",
        "explanation": "This problem can be modeled as finding if all nodes in a graph are reachable from a starting node (room 0). The rooms represent the vertices (V) and the keys represent the directed edges (E). This solution employs a Breadth-First Search (BFS) to traverse the graph. It uses a queue to manage the rooms to visit and a boolean array to track visited rooms. Starting from room 0, it explores all reachable rooms. Finally, it checks the visited array to see if all rooms were reached. The time complexity is $O(V + E)$ because every room and key is processed once. The space complexity is $O(V)$ to store the queue and the visited array."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        int n = rooms.size();\n        vector<bool> vis(n, false);\n        queue<int> q;\n        q.push(0);\n        vis[0] = true;\n        \n        while(!q.empty()){\n            int room = q.front();\n            q.pop();\n            for(auto it: rooms[room]){\n                if(!vis[it]){\n                    q.push(it);\n                    vis[it] = true;\n                }\n            }\n        }\n        for(auto it: vis)\n            if(!it)\n                return false;\n        return true;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Graph"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Keys and Rooms",
    "problemStatement": "There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.",
    "examples": [
      {
        "id": 1,
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "We visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true."
      },
      {
        "id": 2,
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "We can not enter room number 2 since the only key that unlocks it is in that room."
      }
    ],
    "constraints": [
      "n == rooms.length",
      "2 <= n <= 1000",
      "0 <= rooms[i].length <= 1000",
      "1 <= sum(rooms[i].length) <= 3000",
      "0 <= rooms[i][j] < n",
      "All the values of rooms[i] are unique."
    ]
  },
  "solutions": [
    {
      "approach_name": "Graph Traversal (BFS)",
      "analysis": {
        "time_complexity": "$O(V + E)$",
        "space_complexity": "$O(V)$",
        "explanation": "This problem can be modeled as finding if all nodes in a graph are reachable from a starting node (room 0). The rooms represent the vertices (V) and the keys represent the directed edges (E). This solution employs a Breadth-First Search (BFS) to traverse the graph. It uses a queue to manage the rooms to visit and a boolean array to track visited rooms. Starting from room 0, it explores all reachable rooms. Finally, it checks the visited array to see if all rooms were reached. The time complexity is $O(V + E)$ because every room and key is processed once. The space complexity is $O(V)$ to store the queue and the visited array."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        int n = rooms.size();\n        vector<bool> vis(n, false);\n        queue<int> q;\n        q.push(0);\n        vis[0] = true;\n        \n        while(!q.empty()){\n            int room = q.front();\n            q.pop();\n            for(auto it: rooms[room]){\n                if(!vis[it]){\n                    q.push(it);\n                    vis[it] = true;\n                }\n            }\n        }\n        for(auto it: vis)\n            if(!it)\n                return false;\n        return true;\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Graph"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "Evaluate Reverse Polish Notation",
    "problemStatement": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\n\nEvaluate the expression. Return an integer that represents the value of the expression.\n\nNote that:\n- The valid operators are '+', '-', '*', and '/'.\n- Each operand may be an integer or another expression.\n- The division between two integers always truncates toward zero.\n- There will not be any division by zero.\n- The input represents a valid arithmetic expression in a reverse polish notation.\n- The answer and all the intermediate calculations can be represented in a 32-bit integer.",
    "examples": [
      {
        "id": 1,
        "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "output": "9",
        "explanation": "((2 + 1) * 3) = 9"
      },
      {
        "id": 2,
        "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "output": "6",
        "explanation": "(4 + (13 / 5)) = 6"
      },
      {
        "id": 3,
        "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
        "output": "22",
        "explanation": "((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
      }
    ],
    "constraints": [
      "1 <= tokens.length <= 10^4",
      "tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]."
    ]
  },
  "solutions": [
    {
      "approach_name": "Stack-based Evaluation",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(n)$",
        "explanation": "The standard way to evaluate a Reverse Polish Notation (RPN) expression is by using a stack. The algorithm iterates through the tokens: if a token is a number, it's pushed onto the stack. If it's an operator, the top two operands are popped, the operation is performed, and the result is pushed back onto the stack. After iterating through all tokens, the stack will contain a single element, which is the final result. This approach requires a single pass, leading to $O(n)$ time complexity. The space complexity is also $O(n)$ for storing operands on the stack in the worst case."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n    stack<long long> s;\n    for(auto& t : tokens){\n            if(t == \"+\" || t == \"-\" || t == \"*\" || t == \"/\") {\n            long long op1 = s.top(); s.pop();\n            long long op2 = s.top(); s.pop();\n            if(t == \"+\") op1 = op2 + op1; \n            if(t == \"-\") op1 = op2 - op1;\n            if(t == \"/\") op1 = op2 / op1;\n            if(t == \"*\") op1 = op2 * op1;   \n                s.push(op1);\n        }\n            else \n                s.push(stoll(t));      \n        }\n    return s.top(); \n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Sorting"
    ],
    "difficulty": "Medium"
  }
}

{
  "question": {
    "title": "My Calendar III",
    "problemStatement": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.)\n\nYou are given some events [startTime, endTime), after each given event, return an integer k representing the maximum k-booking between all the previous events.\n\nImplement the MyCalendarThree class:\n- MyCalendarThree() Initializes the object.\n- int book(int startTime, int endTime) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar.",
    "examples": [
      {
        "id": 1,
        "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
        "output": "[null, 1, 1, 2, 3, 3, 3]",
        "explanation": "MyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // return 1\nmyCalendarThree.book(50, 60); // return 1\nmyCalendarThree.book(10, 40); // return 2\nmyCalendarThree.book(5, 15); // return 3\nmyCalendarThree.book(5, 10); // return 3\nmyCalendarThree.book(25, 55); // return 3"
      }
    ],
    "constraints": [
      "0 <= startTime < endTime <= 10^9",
      "At most 400 calls will be made to book."
    ]
  },
  "solutions": [
    {
      "approach_name": "Boundary Counting (Line Sweep)",
      "analysis": {
        "time_complexity": "$O(N)$ per `book` call",
        "space_complexity": "$O(N)$",
        "explanation": "This solution uses a line sweep algorithm. A sorted map (or dictionary) is used to store the timeline of events. For each booking from `start` to `end`, we increment the count at the `start` time and decrement the count at the `end` time. To find the maximum number of concurrent events (the k-booking), we iterate through the sorted timeline, maintaining a running sum of active events. The maximum value this sum reaches at any point is the answer. If there are `N` bookings, a single `book` call requires two map insertions (each $O(\\log N)$) and a sweep through the map (which has at most $2N$ points, taking $O(N)$ time). Thus, the time per call is $O(N)$, and the space is $O(N)$ to store the timeline."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class MyCalendarThree {\npublic:\n    map<int, int> timeline;      \n    MyCalendarThree() {\n        \n    }\n    \n    int book(int s, int e) {\n        timeline[s]++;\n        timeline[e]--;\n        int ongoing = 0, k = 0;\n        for(pair<int, int> t: timeline)\n            k = max(k, ongoing += t.second);\n        return k;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "from itertools import accumulate\nfrom sortedcontainers import SortedDict\n\nclass MyCalendarThree:\n\n    def __init__(self):\n        self.timeline = SortedDict()\n\n    def book(self, start: int, end: int) -> int:\n        self.timeline[start] = self.timeline.get(start, 0) + 1\n        self.timeline[end] = self.timeline.get(end, 0) - 1\n        return max(accumulate(self.timeline.values()))"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Segment Tree"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "Best Time to Buy and Sell Stock IV",
    "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "examples": [
      {
        "id": 1,
        "input": "k = 2, prices = [2,4,1]",
        "output": "2",
        "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
      },
      {
        "id": 2,
        "input": "k = 2, prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
      }
    ],
    "constraints": [
      "1 <= k <= 100",
      "1 <= prices.length <= 1000",
      "0 <= prices[i] <= 1000"
    ]
  },
  "solutions": [
    {
      "approach_name": "Dynamic Programming",
      "analysis": {
        "time_complexity": "$O(n \\cdot k)$",
        "space_complexity": "$O(k)$",
        "explanation": "This problem is solved using dynamic programming. We maintain a DP array where `dp[i][0]` represents the minimum cost to make the `i`-th buy, and `dp[i][1]` is the maximum profit after the `i`-th sell. We iterate through each price `p` and update the DP table for each transaction `i` from 1 to `k`. The cost for the `i`-th buy is updated by `min(current_cost, p - profit_from_prev_sell)`. The profit for the `i`-th sell is updated by `max(current_profit, p - cost_of_current_buy)`. After iterating through all prices, `dp[k][1]` contains the maximum profit. The time complexity is $O(n \\cdot k)$ from the nested loops, and the space complexity is $O(k)$ for the DP table."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0)  return 0;\n        vector<vector<int>> dp(k+1, vector<int>(2));\n        \n        for(int i = 0; i <= k; i++){\n            dp[i][0] = INT_MAX; // cost to buy\n            dp[i][1] = 0;       // profit to sell\n        }\n        \n        for(auto &p: prices){\n            for(int i = 1; i <= k; i++){\n                dp[i][0] = min(dp[i][0], p - dp[i-1][1]);\n                dp[i][1] = max(dp[i][1], p - dp[i][0]);\n            }\n        }\n        return dp[k][1];\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if k == 0: return 0\n        # dp[i][0] = cost to buy, dp[i][1] = profit to sell for transaction i\n        dp = [[float('inf'), 0] for _ in range(k + 1)]\n              \n        for p in prices:\n            for i in range(1, k + 1):\n                dp[i][0] = min(dp[i][0], p - dp[i-1][1])\n                dp[i][1] = max(dp[i][1], p - dp[i][0])\n        \n        return dp[k][1]"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "K Inverse Pairs Array",
    "problemStatement": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].\n\nGiven two integers n and k, return the number of different arrays consisting of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10^9 + 7.",
    "examples": [
      {
        "id": 1,
        "input": "n = 3, k = 0",
        "output": "1",
        "explanation": "Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs."
      },
      {
        "id": 2,
        "input": "n = 3, k = 1",
        "output": "2",
        "explanation": "The array [1,3,2] and [2,1,3] have exactly 1 inverse pair."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "0 <= k <= 1000"
    ]
  },
  "solutions": [
    {
      "approach_name": "Optimized Dynamic Programming",
      "analysis": {
        "time_complexity": "$O(n \\cdot k)$",
        "space_complexity": "$O(k)$",
        "explanation": "This problem can be solved with dynamic programming. Let `dp[i][j]` be the number of permutations using numbers `1..i` with `j` inverse pairs. A naive recurrence would be $O(n^2k)$. This can be optimized by observing the relationship `dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]`. The provided solution implements this optimized recurrence. Furthermore, it uses space optimization, as calculating the row `i` only requires the previous row `i-1`, reducing the space complexity from $O(nk)$ to $O(k)$. The final time complexity is $O(n \\cdot k)$."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int kInversePairs(int n, int k) {\n        int dp[2][1001] = {};\n        dp[0][0] = 1;\n        int mod = 1e9 + 7;\n        for(int i = 1; i <= n; i++) {\n            int current = i % 2;\n            int prev = (i - 1) % 2;\n            dp[current][0] = 1;\n            for(int j = 1; j <= k; j++) {\n                dp[current][j] = (dp[prev][j] + dp[current][j-1]) % mod;\n                if(j >= i) {\n                    dp[current][j] = (dp[current][j] - dp[prev][j-i] + mod) % mod;\n                }\n            }\n        }\n        return dp[n%2][k];\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "Merge k Sorted Lists",
    "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
    "examples": [
      {
        "id": 1,
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6"
      },
      {
        "id": 2,
        "input": "lists = []",
        "output": "[]",
        "explanation": null
      },
      {
        "id": 3,
        "input": "lists = [[]]",
        "output": "[]",
        "explanation": null
      }
    ],
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "lists[i] is sorted in ascending order.",
      "The sum of lists[i].length will not exceed 10^4."
    ]
  },
  "solutions": [
    {
      "approach_name": "Divide and Conquer (Merge in Pairs)",
      "analysis": {
        "time_complexity": "$O(N \\log k)$",
        "space_complexity": "$O(N)$",
        "explanation": "This solution uses a divide and conquer strategy. It iteratively merges pairs of lists: the first with the last, the second with the second-to-last, and so on. This process halves the number of lists in each pass. This is repeated until only one merged list remains. The process repeats a total of $O(\\log k)$ times, and in each pass, every node from all lists is processed once, leading to a total time complexity of $O(N \\log k)$, where N is the total number of nodes and k is the number of lists. The space complexity of the provided solution is $O(N)$ due to the recursion depth of the `mergeTwoLists` helper function in a worst-case scenario. An iterative helper would reduce this to $O(1)$ auxiliary space."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    ListNode *mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if (NULL == l1) return l2;\n        else if (NULL == l2) return l1;\n        \n        if (l1->val <= l2->val) {\n            l1->next = mergeTwoLists(l1->next, l2);\n            return l1;\n        }\n        \n        else {\n            l2->next = mergeTwoLists(l1, l2->next);\n            return l2;\n        }\n    }\n    \n    ListNode *mergeKLists(vector<ListNode *> &lists) {\n        if (lists.empty()) return NULL;\n        int len = lists.size();\n        \n        while (len > 1) {\n            for (int i = 0; i < len / 2; ++i) {\n                lists[i] = mergeTwoLists(lists[i], lists[len - 1 - i]);\n            }\n            \n            len = (len + 1) / 2;\n        }\n        \n        return lists.front();\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Linked List"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "Minimum Window Substring",
    "problemStatement": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.",
    "examples": [
      {
        "id": 1,
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
      },
      {
        "id": 2,
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "The entire string s is the minimum window."
      },
      {
        "id": 3,
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string."
      }
    ],
    "constraints": [
      "m == s.length",
      "n == t.length",
      "1 <= m, n <= 10^5",
      "s and t consist of uppercase and lowercase English letters."
    ]
  },
  "solutions": [
    {
      "approach_name": "Sliding Window",
      "analysis": {
        "time_complexity": "$O(m + n)$",
        "space_complexity": "$O(1)$",
        "explanation": "This problem is a classic application of the sliding window technique. We use two pointers, `low` and `high`, to represent the window. A frequency map is used to store the character counts required by string `t`. The `high` pointer expands the window to the right. When the window becomes 'valid' (contains all required characters), we record its length and then try to shrink it from the left by moving the `low` pointer, seeking a smaller valid window. This process of expanding and shrinking continues until the `high` pointer traverses the entire string `s`. Since each pointer traverses the string at most once, the time complexity is linear, $O(m+n)$. The space for the frequency map is constant as the character set is fixed."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        vector<int> mp(128, 0);\n        for(auto c: t){\n            mp[c]++;\n        }\n        int low = 0, high = 0, m = s.size(), n = t.size(), minStart = 0, minLen = INT_MAX;\n        \n        while(high < m){\n            if(mp[s[high]] > 0)\n                n--;\n            mp[s[high]]--;\n            high++;\n            \n            while(n == 0){\n                if(high - low < minLen){\n                    minStart = low;\n                    minLen = high - low;\n                }\n                mp[s[low]]++;\n                if(mp[s[low]] > 0)\n                    n++;\n                low++;\n            }\n        }\n        if(minLen != INT_MAX)\n            return s.substr(minStart, minLen);\n        return \"\";\n    }\n};"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "String"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "Longest Valid Parentheses",
    "problemStatement": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
    "examples": [
      {
        "id": 1,
        "input": "s = \"(()\"",
        "output": "2",
        "explanation": "The longest valid parentheses substring is \"()\"."
      },
      {
        "id": 2,
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\"."
      },
      {
        "id": 3,
        "input": "s = \"\"",
        "output": "0",
        "explanation": null
      }
    ],
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is '(', or ')'."
    ]
  },
  "solutions": [
    {
      "approach_name": "Stack with Index Tracking",
      "analysis": {
        "time_complexity": "$O(n)$",
        "space_complexity": "$O(n)$",
        "explanation": "This approach uses a stack to efficiently track the indices of parentheses. The stack is initialized with a sentinel value (e.g., -1) to act as a base for length calculations. When an opening parenthesis is found, its index is pushed onto the stack. When a closing parenthesis is encountered, we pop from the stack, signifying a match. The length of the newly formed valid substring is the difference between the current index and the index now at the top of the stack. The maximum length is updated accordingly. This method requires a single pass through the string, resulting in $O(n)$ time complexity. The space complexity is also $O(n)$ for the stack in the worst-case scenario (e.g., a string of all opening parentheses)."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        st.push(-1);\n        int ans = 0;\n        \n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '('){\n                st.push(i);\n            }\n            else {\n                st.pop();\n                if (st.empty()) {\n                    st.push(i);\n                }\n                else {\n                    ans = max(ans, i - st.top());\n                }\n            }\n        }\n        return ans;\n    }\n};"
        },
        {
          "language": "Python",
          "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        st = [-1]\n        ans = 0\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                st.append(i)\n            else:\n                st.pop()\n                if not st:\n                    st.append(i)\n                else:\n                    ans = max(ans, i - st[-1])\n        \n        return ans"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Stack and Queue"
    ],
    "difficulty": "Hard"
  }
}

{
  "question": {
    "title": "Poor Pigs",
    "problemStatement": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n1. Choose some live pigs to feed.\n2. For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3. Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n4. After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5. Repeat this process until you run out of time.\n\nGiven buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.",
    "examples": [
      {
        "id": 1,
        "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
        "output": "2",
        "explanation": "We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous."
      },
      {
        "id": 2,
        "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
        "output": "2",
        "explanation": "We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed."
      }
    ],
    "constraints": [
      "1 <= buckets <= 1000",
      "1 <= minutesToDie <= minutesToTest <= 100"
    ]
  },
  "solutions": [
    {
      "approach_name": "Mathematical (Combinatorics)",
      "analysis": {
        "time_complexity": "$O(1)$",
        "space_complexity": "$O(1)$",
        "explanation": "This problem can be solved using a mathematical formula derived from combinatorics. The number of testing rounds available is `T = minutesToTest / minutesToDie`. Each pig can have `T+1` distinct outcomes (dying in round 1, 2, ..., T, or surviving all rounds). With `p` pigs, we can represent `(T+1)^p` unique states. To distinguish between all `buckets`, this number of states must be at least equal to the number of buckets. This gives the inequality `(T+1)^p >= buckets`. By solving for `p` using logarithms, we get `p >= log(buckets) / log(T+1)`. Since the number of pigs must be an integer, we take the ceiling of the result. This allows for a direct, constant-time calculation."
      },
      "implementations": [
        {
          "language": "C++",
          "code": "#include <cmath>\n\nclass Solution {\npublic:\n    int poorPigs(int b, int m1, int m2) {\n        return ceil(log(b)/log(m2/m1 +1));\n    }\n};"
        },
        {
          "language": "Python",
          "code": "from math import log, ceil\n\nclass Solution:\n    def poorPigs(self, b: int, m1: int, m2: int) -> int:\n        return ceil(log(b)/log(m2/m1 +1))"
        }
      ]
    }
  ],
  "metadata": {
    "topic": [
      "Math"
    ],
    "difficulty": "Hard"
  }
}

